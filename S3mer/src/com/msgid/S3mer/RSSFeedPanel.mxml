<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" width="971" height="81" backgroundColor="#000000"
	 resize="onResize(event)"
	  xmlns:display="flash.display.*"
	   verticalScrollPolicy="off" horizontalScrollPolicy="off" backgroundAlpha="0.0">
	<mx:states>
		<mx:State name="hidden_bottom">
			<mx:SetStyle target="{headline}" name="bottom" value="-100"/>
			<mx:SetStyle target="{headline}" name="top" value="100"/>
		</mx:State>
		<mx:State name="hidden_top">
			<mx:SetStyle target="{headline}" name="bottom" value="100"/>
			<mx:SetStyle target="{headline}" name="top" value="-100"/>
		</mx:State>
		<mx:State name="sidescroll" enterState="changeToSideScroll(event)">
			<mx:RemoveChild target="{headtext}"/>
			<mx:RemoveChild target="{bodytext}"/>
			<mx:AddChild relativeTo="{headline}" position="lastChild">
				<mx:Label fontFamily="Arial" fontSize="41" color="#000000" id="headtext1" fontWeight="bold" letterSpacing="-2" truncateToFit="false" x="1" verticalCenter="0"/>
			</mx:AddChild>
			<mx:AddChild relativeTo="{headline}" position="lastChild">
				<mx:Label fontFamily="Arial" fontSize="41" color="#000000" id="headtext2" fontWeight="bold" letterSpacing="-2" truncateToFit="false" x="88" verticalCenter="0"/>
			</mx:AddChild>
			<mx:AddChild relativeTo="{headline}" position="lastChild">
				<mx:Label fontFamily="Arial" fontSize="41" color="#000000" id="headtext3" fontWeight="bold" letterSpacing="-2" truncateToFit="false" x="177" verticalCenter="0"/>
			</mx:AddChild>
			<mx:AddChild relativeTo="{headline}" position="lastChild">
				<mx:Label fontFamily="Arial" fontSize="41" color="#000000" id="spacer1" fontWeight="bold" letterSpacing="-2" truncateToFit="false" verticalCenter="0" x="54" enabled="true" width="25"/>
			</mx:AddChild>
			<mx:AddChild relativeTo="{headline}" position="lastChild">
				<mx:Label fontFamily="Arial" fontSize="41" color="#000000" id="spacer2" fontWeight="bold" letterSpacing="-2" truncateToFit="false" verticalCenter="0" x="108" enabled="true" width="25"/>
			</mx:AddChild>
			<mx:AddChild relativeTo="{headline}" position="lastChild">
				<mx:Label fontFamily="Arial" fontSize="41" color="#000000" id="spacer3" fontWeight="bold" letterSpacing="-2" truncateToFit="false" verticalCenter="0" x="162" enabled="true" width="25"/>
			</mx:AddChild>
			<mx:SetProperty target="{headline}" name="y"/>
			<mx:SetStyle target="{headline}" name="top" value="0"/>
			<mx:SetProperty target="{headline}" name="height"/>
			<mx:SetStyle target="{headline}" name="bottom" value="0"/>
			<mx:SetProperty target="{headline}" name="width"/>
			<mx:SetProperty target="{headline}" name="x"/>
			<mx:SetStyle target="{headline}" name="right" value="0"/>
			<mx:SetStyle target="{headline}" name="left" value="116"/>
			<mx:SetProperty target="{headline}" name="cacheAsBitmap" value="true"/>
			<mx:SetProperty target="{headtext1}" name="cacheAsBitmap" value="true"/>
			<mx:SetProperty target="{headtext2}" name="cacheAsBitmap" value="true"/>
			<mx:SetProperty target="{headtext3}" name="cacheAsBitmap" value="true"/>
			<mx:SetProperty target="{spacer1}" name="cacheAsBitmap" value="true"/>
			<mx:SetProperty target="{spacer2}" name="cacheAsBitmap" value="true"/>
			<mx:SetProperty target="{spacer3}" name="cacheAsBitmap" value="true"/>
			<mx:AddChild position="lastChild">
				<mx:Image source="assets/rssMask2.png" left="124" right="0" top="0" bottom="0" id="headline_mask" cacheAsBitmap="true"/>
			</mx:AddChild>
		</mx:State>
	</mx:states>
	
	<mx:transitions>
		<mx:Transition fromState="*" toState="hidden_bottom">
			<mx:Parallel effectEnd="play_next_stage2(event)">
				<mx:Move target="{headline}"/>
				<mx:AnimateProperty property="alpha" target="{headline}" fromValue="1.0" toValue="0.0"/>
			</mx:Parallel>
		</mx:Transition>
		
		<mx:Transition fromState="hidden_bottom" toState="">
			<mx:Parallel effectEnd="this._playNextTimer.start();">
				<mx:Move target="{headline}"/>
				<mx:AnimateProperty property="alpha" target="{headline}" fromValue="0.0" toValue="1.0"/>
			</mx:Parallel>
		</mx:Transition>
		
		<mx:Transition fromState="*" toState="hidden_top">
			<mx:Parallel effectEnd="play_next_stage2(event)">
				<mx:Move target="{headline}"/>
				<mx:AnimateProperty property="alpha" target="{headline}" fromValue="1.0" toValue="0.0"/>
			</mx:Parallel>
		</mx:Transition>
		
		<mx:Transition fromState="hidden_top" toState="">
			<mx:Parallel effectEnd="this._playNextTimer.start();">
				<mx:Move target="{headline}"/>
				<mx:AnimateProperty property="alpha" target="{headline}" fromValue="0.0" toValue="1.0"/>
			</mx:Parallel>
		</mx:Transition>
	</mx:transitions>
	
	<mx:SWFLoader  scaleContent="true" id="logoSWF" verticalAlign="middle" horizontalAlign="center" width="107" x="9" top="0" bottom="0"/>
	<mx:Canvas id="headline" verticalScrollPolicy="off" horizontalScrollPolicy="off" backgroundColor="#000000" backgroundAlpha="0.0" alpha="1.0" left="126" top="0" bottom="0" right="15">
		<mx:Label fontFamily="Arial" fontSize="41" color="#000000" id="headtext" fontWeight="bold" letterSpacing="-2" truncateToFit="false" y="10" left="1"/>
		<mx:Label text="" fontFamily="Arial" fontSize="20" color="#000000" id="bodytext" fontWeight="bold" letterSpacing="-1" truncateToFit="false" y="{headtext.y + headtext.height - 8}" left="1" alpha="0.45"/>
	</mx:Canvas>
	

	<mx:Style>
		@font-face {
		    src:url("/assets/Helvetica Neue Condensed Black.ttf");
		    fontFamily: HelvNeueBlack;
		}
	</mx:Style>
	
	<mx:Script>
		<![CDATA[
			import mx.controls.HTML;
			import flash.text.engine.FontMetrics;
			import mx.events.FlexEvent;
			import mx.events.StateChangeEvent;
//			import com.adobe.utils.;
			import mx.events.ResizeEvent;
			import mx.controls.Label;
			import mx.events.EffectEvent;
			import mx.effects.Move;
			
			private var resizing:Boolean = false;
			
			private function onResize(e:ResizeEvent):void {
				resize();
			}
			
			public function set color(val:String):void {
				this._color = val;
				
				if (headtext1 != null ) { 
					this.headtext.setStyle("color","#" + val);
					this.bodytext.setStyle("color","#" + val);
				}
			}
			
			private function set mode(val:int):void {
				if( this._stopped == true ) {
					this._mode = val;
				}
			}
			
			public function get color():String {
				return this._color;
			}
			
			private const _origWidth:int = 971;
			private const _origHeight:int = 81;
			
			public var delay:int;
			public var source:String;
			public var logoUrl:String;
			
			private var _playNextTimer:Timer;
			private var _reloadTimer:Timer;
			private var _scrollTimer:Timer;
			
			private var _lastUpdateDate:Date;
			private var _RSSXML:XML = new XML();
			private var _loader:URLLoader;
			private var _currentHeadline:int = 0;
			
			private var _color:String;
			
			private var _stopped:Boolean = false;
			private var _feedType:int;
			private var _mode:int = MODE_SCROLL;
			
			
			public static const MODE_SLIDE:int = 0;
			public static const MODE_SCROLL:int = 1;
			
			public var SCROLL_TIMER_DELAY:int = 40;
			public var SCROLL_TIMER_DELTA:Number = -3;
			
			
			
			//Change the following 4 functions to if you want to support more types of feeds
			public static const FEED_INVALID:int = 0;
			public static const FEED_ATOM:int = 1;
			public static const FEED_RSS:int = 2;
	
			private function get headlineDescription():String {
				var ret:String;
				
				switch(this._feedType) {
					case FEED_INVALID:
						ret = "";
						break;
					case FEED_ATOM:
						ret = "";
						break;
					case FEED_RSS:
						ret = this._RSSXML.channel.item[this._currentHeadline].description;
						break;
				}
				
				return ret;
			}
			
			private function get headlineTitle():String {
				var ret:String;
				
				switch(this._feedType) {
					case FEED_INVALID:
						ret = "";
						break;
					case FEED_ATOM:
						ret = "";
						break;
					case FEED_RSS:
						ret = this._RSSXML.channel.item[this._currentHeadline].title;
												
						break;
					
				}
				return ret;
			}
			
			private function get numHeadlines():int {
				var ret:int;
				
				switch(this._feedType) {
					case FEED_INVALID:
						ret = 0;
						break;
					case FEED_ATOM:
						ret = 0;
						break;
					case FEED_RSS:
						ret = new XMLList(this._RSSXML.channel.item).length();
						break;
					
				}
				return ret;
			}
			
			private function OnRSSLoadComplete(e:Event):void {
				_reloadTimer.delay = 1*60*1000;
				_reloadTimer.start();
				this.visible = true;
				
				try {
				var tmpRSS:XML = new XML(_loader.data); // Load data into a temp variable
				} catch (e:Error) {
					_reloadTimer.delay = 1*60*1000;
					_reloadTimer.start();
					return;
				}

				this._feedType = identifyRSS(tmpRSS);
				
				
				switch(this._feedType) {
					case FEED_INVALID:
					case FEED_ATOM:
						// No data loaded, or data is empty....
						tmpRSS = new XML();
						
						// If the last update was more than 24 Hours ago, then set RSS to an empty one
						if (new Date().getTime() - this._lastUpdateDate.getTime() > 24*60*60*1000) {
							this._RSSXML = tmpRSS;
							this._currentHeadline = 0;
						}
						break;
					case FEED_RSS:
						this._lastUpdateDate = new Date();
						
						if (tmpRSS.toString() == this._RSSXML.toString()) {
							// Do nothing as XML was not updated
						} else {
							if( this._playNextTimer.running ) {
								this._playNextTimer.stop();
							}
							
							this._RSSXML = tmpRSS;
							this._currentHeadline = 0;
							
							switch(this._mode) {
								case MODE_SCROLL:
									if ( !this._scrollTimer.running ) {
										this._scrollTimer.start();
									}
									break;
								case MODE_SLIDE:
									if ( !this._playNextTimer.running ) {
										this._playNextTimer.start();
									}
									this.resize();
									break;
							}
						}
					
						break;
				}
				
				this.play_next();
			}
			
			// End feed support functions

			public function play():void {
				trace("RSS URL: " +this.source);
				trace("Logo URL: " +this.logoUrl);
				trace("delay: " +this.delay);
				
//				this._mode = MODE_SCROLL;
				
				switch(this._mode) {
					case MODE_SCROLL:
						this.currentState = "sidescroll";
						break;
					case MODE_SLIDE:
						this.currentState = "";
						play_step2();
						break;
				}
			}
			
			private function play_step2():void {
				
				if (_playNextTimer == null ) {
					_playNextTimer = new Timer(this.delay);
					_playNextTimer.addEventListener(TimerEvent.TIMER, OnPlayNextTimer,false,0,true);
				} else {
					_playNextTimer.delay = this.delay;
				}

				if (_reloadTimer == null ) {
					_reloadTimer = new Timer(10*60*1000);
					_reloadTimer.addEventListener(TimerEvent.TIMER, OnReloadTimer,false,0,true);
				} else {
					_reloadTimer.delay = 10*60*1000;
				}

				if (_scrollTimer == null ) {
					_scrollTimer = new Timer(SCROLL_TIMER_DELAY);
					_scrollTimer.addEventListener(TimerEvent.TIMER, OnScrollTimer,false,0,true);
				} else {
					_scrollTimer.delay = SCROLL_TIMER_DELAY;
				}

				this._lastUpdateDate = new Date();
				this._lastUpdateDate.setTime(0);

				this.RSSLoadBegin();
				
				this.logoSWF.source = this.logoUrl;
				
				this.resize();

				if (headtext != null ) { 
					this.headtext.setStyle("color","#" + this._color);
				}
				
				if (bodytext != null ) {
					this.bodytext.setStyle("color","#" + this._color);
				}
				
				this._stopped = false;
				
				_reloadTimer.start();
			}
			
			public function changeToSideScroll(e:FlexEvent):void {
				this.headtext1.x = this.width;
				this.headtext2.x = this.width+50;
				this.headtext3.x = this.width+100;
				
				this.headtext1.setStyle("color","#" + this._color);
				this.headtext2.setStyle("color","#" + this._color);
				this.headtext3.setStyle("color","#" + this._color);
				this.spacer1.setStyle("color","#" + this._color);
				this.spacer2.setStyle("color","#" + this._color);
				this.spacer3.setStyle("color","#" + this._color);
				
				this.headline.mask = this.headline_mask;
//				this.headtext1.mask = this.headline_mask;
//				this.headtext2.mask = this.headline_mask;
//				this.headtext3.mask = this.headline_mask;
//				this.spacer1.mask = this.headline_mask;
//				this.spacer2.mask = this.headline_mask;
//				this.spacer3.mask = this.headline_mask;
				
				repositionSideScrollElements();
				play_step2();
			}
			
			public function repositionSideScrollElements():void {
				this.headtext1.validateNow();
				this.headtext2.validateNow();
				this.headtext3.validateNow();
				
				var currState:int = calculateState();
				
				switch(currState) {
					case 1:
						this.spacer1.x = this.headtext1.x + this.headtext1.textWidth + 10;
						this.headtext2.x = this.spacer1.x + this.spacer1.width + 10;
						this.spacer2.x = this.headtext2.x + this.headtext2.textWidth + 10;
						this.headtext3.x = this.spacer2.x + this.spacer2.width + 10;
						this.spacer3.x = this.headtext3.x + this.headtext3.textWidth + 10;
						
						break;
					case 2:
						this.spacer2.x = this.headtext2.x + this.headtext2.textWidth + 10;
						this.headtext3.x = this.spacer2.x + this.spacer2.width + 10;
						this.spacer3.x = this.headtext3.x + this.headtext3.textWidth + 10;
						this.headtext1.x = this.spacer3.x + this.spacer3.width + 10;
						this.spacer1.x = this.headtext1.x + this.headtext1.textWidth + 10;
						
						break;
					case 3:
						this.spacer3.x = this.headtext3.x + this.headtext3.textWidth + 10;
						this.headtext1.x = this.spacer3.x + this.spacer3.width + 10;
						this.spacer1.x = this.headtext1.x + this.headtext1.textWidth + 10;
						this.headtext2.x = this.spacer1.x + this.spacer1.width + 10;
						this.spacer2.x = this.headtext2.x + this.headtext2.textWidth + 10;
						
						break;
				}
				

			}
			
			private function calculateState():int {
				if( headtext2.x > 0 && headtext3.x > 0 ) {
					return 1;
				}
				
				if( headtext2.x <= 0 && headtext3.x > 0 ) {
					return 2;
				}
				
				if( headtext3.x <= 0 && headtext1.x > 0 ) {
					return 3;
				}
				
				return 1;
			}
			
			public function stop():void {
				this._playNextTimer.stop();
				this._reloadTimer.stop();
				this._stopped = true;
			}
			
			public function resume():void {
				this._stopped = false;
				this._playNextTimer.start();
				this._reloadTimer.start();
				
			}
			
			public function resize():void {
				var scaleX:Number;
				var scaleY:Number
				var adjustingFonts:Boolean;
				var fontSize:Number;
				
				if( this._mode == MODE_SCROLL ) {
					if ( this.resizing == false && headtext1 != null) {
						this.resizing = true;
						scaleX = (this.width / this._origWidth);
						scaleY = (this.height / this._origHeight);
						
						scale = scaleY;
						
						this.headtext1.validateNow();
						
						scrollChangeFontSize((Math.floor(39*scale)).toString());
						
						
						adjustingFonts = true;
						do {					
							if ( this.headtext1.text != "" && this.headtext1.y + this.headtext1.measureText(this.headtext1.text).height > this.headline.height ) {
								fontSize = Number(this.headtext1.getStyle("fontSize"));
								
								fontSize -= 1;
								
								scrollChangeFontSize(fontSize.toString());
							} else {
								adjustingFonts = false;
							}
						} while( adjustingFonts && fontSize > 2 )
	
	
						this.headtext.width = headline.width;
						this.bodytext.width = headline.width;
						
						this.resizing = false;
					}

					return;
				} else {
				
					if ( this.resizing == false ) {
						this.resizing = true;
						scaleX = (this.width / this._origWidth);
						scaleY = (this.height / this._origHeight);
						
						var scale:Number;
						
						if (scaleX >scaleY ) {
							scale = scaleY;
						} else {
							scale = scaleX;
						}
						
						scale = scaleY;
						
						this.headtext.setStyle("fontSize", (Math.floor(39*scale)).toString());
						this.bodytext.setStyle("fontSize", (Math.floor(20*scale)).toString());
						
						this.headtext.y = 4*scale - 2;
//						this.bodytext.y = this.headtext.y + this.headtext.measureText(this.headtext.text).height - 6;
						
						adjustingFonts = true;
						do {					
							if ( this.bodytext.text != "" && this.bodytext.y + this.bodytext.measureText(this.bodytext.text).height > this.headline.height ) {
								fontSize = Number(this.headtext.getStyle("fontSize"));
								
								fontSize -= 1;
								this.headtext.setStyle("fontSize", fontSize.toString());
//								this.bodytext.y = this.headtext.y + this.headtext.measureText(this.headtext.text).height - 6;
	//							Logger.addEvent("re-adjusting fonts");
							} else {
								adjustingFonts = false;
							}
						} while( adjustingFonts && fontSize > 2 )
	
	
						this.headtext.width = headline.width;
						this.bodytext.width = headline.width;
						
						this.resizing = false;
					}
				}
			}
			
			private function scrollChangeFontSize(newSize:String):void {
				this.headtext1.setStyle("fontSize", newSize);
				this.headtext2.setStyle("fontSize", newSize);
				this.headtext3.setStyle("fontSize", newSize);
				this.spacer1.setStyle("fontSize", newSize);
				this.spacer2.setStyle("fontSize", newSize);
				this.spacer3.setStyle("fontSize", newSize);
				
				repositionSideScrollElements();
			}
			
			private function RSSLoadBegin():void {
				var _loaderReq:URLRequest;

				if (_loader == null) {
					_loader = new URLLoader();
					_loader.dataFormat = URLLoaderDataFormat.TEXT;
					_loader.addEventListener(Event.COMPLETE,OnRSSLoadComplete,false,0,true);
					_loader.addEventListener(IOErrorEvent.IO_ERROR,OnIOError,false,0,true);
				}
				
				_loaderReq = new URLRequest(this.source);
//				_loaderReq.setLoginCredentials("development","mils0ft");

				_loader.load(_loaderReq);
			}
			
			private function OnIOError(e:IOErrorEvent):void {
				Logger.addEvent("RSS FAILED: Probably not connected");
				_reloadTimer.delay = 5*1000;
				_reloadTimer.start();
				this.visible = false;
			}
		 

			
			private function OnReloadTimer(e:TimerEvent):void {
				if ( this._stopped == true ) {
					return;
				}

				RSSLoadBegin();
			}
			
			private function OnScrollTimer(e:TimerEvent):void {
				var currState:int = calculateState();
				
				switch(currState) {
					case 1:
						this.headtext1.x += SCROLL_TIMER_DELTA;
						break;
					case 2:
						this.headtext2.x += SCROLL_TIMER_DELTA;
						break;
					case 3:
						this.headtext3.x += SCROLL_TIMER_DELTA;
						break;
				}
				
				
				repositionSideScrollElements();
				
				if( currState != calculateState() ) {
					switch(currState) {
						case 1:
							updateHeadline(headtext1);
							break;
						case 2:
							updateHeadline(headtext2);
							break;
						case 3:
							updateHeadline(headtext3);
							break;
					}
				}
			}

			
			private function identifyRSS(responseXML:XML):int {
				if(new XMLList(responseXML.channel.item).length() > 0) {
					return FEED_RSS;
				} else {
					return FEED_INVALID;
				}
			}
			
			private function OnPlayNextTimer(e:TimerEvent):void {
				if ( this._stopped == true ) {
					return;
				}

				this._playNextTimer.stop();
				
				play_next();
			}
			
			private function play_next():void {
				switch(this._mode) {
					case MODE_SCROLL:
							play_next_scroll();
						break;
					case MODE_SLIDE:				
						if(this.y > this.screen.height/2) { 
							this.currentState = "hidden_bottom"; // TODO: somehow detect if we are at the top of the screen and go to hidden_top instead
						} else {
							this.currentState = "hidden_top";
						}
						break;
				}
			}
			
			private function next_headline():void {
				var headlineIndex:int = this._currentHeadline;

				if ( this._stopped == true ) {
					return;
				}
				
				if(this.numHeadlines == 0) {
					return;
				}

				do {
					this._currentHeadline += 1;
					if (this._currentHeadline > this.numHeadlines - 1) {
						this._currentHeadline = 0;
					}	
				} while(headlineIndex != this._currentHeadline && isHeadlineEmpty())
				 			
			}
			
			private function isHeadlineEmpty():Boolean {
				if(this.headlineDescription == "") {
					return true;
				} else {
					return false;
				}
				
			}
			

			
			private function play_next_stage2(e:EffectEvent):void {
				if(isHeadlineEmpty()) {
					next_headline();
				}
												
				if (this.numHeadlines == 0) {
					headtext.htmlText = this.source;
					bodytext.htmlText = "Actualizando..."
				} else {
					headtext.htmlText = this.cleanupHTML(this.headlineTitle);
					bodytext.htmlText = this.cleanupHTML(this.headlineDescription);
				}
				
				this.truncateText(headtext, this.headline.width);
				this.truncateText(bodytext, this.headline.width);
				
				this.currentState = "";
				next_headline();
			}
			
			private function updateHeadline(obj:Label):void {
				if(isHeadlineEmpty()) {
					next_headline();
				}

				obj.htmlText = this.cleanupHTML(this.headlineTitle);
				obj.validateNow();
				obj.width = obj.textWidth;
				
				next_headline();
				
			}
			
			private function play_next_scroll():void {
				if(isHeadlineEmpty()) {
					next_headline();
				}
												
				spacer1.text = "•";
				spacer2.text = "•";
				spacer3.text = "•";
				if (this.numHeadlines == 0) {
					headtext1.htmlText = this.source;
					headtext2.htmlText = "Actualizando..."
				} else {
					headtext1.htmlText = this.cleanupHTML(this.headlineTitle);
					next_headline();
					headtext2.htmlText = this.cleanupHTML(this.headlineTitle);
					next_headline();
					headtext3.htmlText = this.cleanupHTML(this.headlineTitle);
				}
				
				this.headtext1.validateNow();
//				this.headtext1.text = this.headtext1.text;
//				this.headtext1.validateNow();
				
				this.headtext2.validateNow();
//				this.headtext2.text = this.headtext2.text;
//				this.headtext2.validateNow();
				
				this.headtext3.validateNow();
//				this.headtext3.text = this.headtext3.text;
//				this.headtext3.validateNow();
				
				this.headtext1.width = this.headtext1.textWidth + 10;
				this.headtext2.width = this.headtext2.textWidth + 10;
				this.headtext3.width = this.headtext3.textWidth + 10;
				
				repositionSideScrollElements();
								
				next_headline();
			}
			
			
			private function cleanupHTML(htmlToClean:String):String {
				var ret:String;
				
				ret = htmlToClean;
				ret = keepFirstStringBeforeTag(ret,/<p>/i);
				ret = keepFirstStringBeforeTag(ret,/<br>/i);
				ret = ret.replace(/^\s/,"");
				
				
				return ret;
			}
			
			private function keepFirstStringBeforeTag(htmlStr:String,tag:RegExp):String {
				var ret:String = "";
				var retArr:Array;
				var index:int = 0;
				
				retArr = htmlStr.split(tag);
				
				for(index = 0; index < retArr.length; index++ ) {
					if(retArr[index].toString().replace(" ","") != "") {
						ret = retArr[index];
						break;
					}
				}
				
				
				return ret;
			}
			
			// This function truncates text in bodytext and headertext
			private function truncateText(obj:Label, width:Number):void {
				var txtWidth:Number;
				var txt:String;
				var txtArr:Array;
				
				obj.validateNow();
				txt = obj.text;
//				Logger.addEvent("Truncate Text In: " + txt);
				txtWidth = obj.measureText(txt).width;
				
				while ( txtWidth > width && txt.length > 5 ) {
					txtArr = txt.split(" ");
					txtArr.pop();
					
					txt = txtArr.join(" ") + "...";


					txtWidth = obj.measureText(txt).width;
//					Logger.addEvent("Truncate Text Out");
				}
//				Logger.addEvent("Truncate Text Out: " + txt);
				
				obj.text = txt;
			}
			

		]]>
	</mx:Script>
	
	

	
</mx:Canvas>
